#!/usr/bin/env Rscript

#####################################
##   sPLS to correlate variables   ##
#####################################

pacman::p_load(mixOmics, corrr, igraph, ggraph)

parameters <- commandArgs(trailingOnly=TRUE)
counts.file.A <- as.character(parameters[1]) # First omic dataset
counts.file.B <- as.character(parameters[2]) # Second omic dataset
meta.file <- as.character(parameters[3]) # Metadata to select samples
myfactors <- as.character(parameters[4]) # Column of metadata to separate intro groups
mylevels <- as.character(parameters[5]) # Levels of that factor (in this case, increase and decrease)
study <- as.character(parameters[6]) # Just a string to name the file, for instance, name of the two omics
mycorcut <- as.numeric(as.character(parameters[7])) # Threshold for the Pearson correlation score
Nkeep <- as.numeric(as.character(parameters[8])) # Number of variables to select by LASSO regression (No needed here)

# The following function is used to parse the information of the network generated by mixOmics
asDataFrame <- function(D){
  Dd <- data.frame(x="", y="", r=0, stringsAsFactors=FALSE)
  Dd <- Dd[-1, ]
  for(i in 1:nrow(D)) for(j in 1:ncol(D)) Dd <- rbind(Dd, data.frame(x=rownames(D)[i], y=colnames(D)[j], r=D[i,j],
                                                                     stringsAsFactors=FALSE))
  Dd <- Dd[which(!is.na(Dd$r)), ]
  mypairs <- c(paste(Dd$x[1], Dd$y[1], sep="."), paste(Dd$y[1], Dd$x[1], sep="."))
  ind <- 1
  for(i in 2:nrow(Dd)){
    mypair <- paste(Dd$x[i], Dd$y[i], sep=".")
    if(!is.element(mypair, mypairs)){
      ind <- c(ind, i)
      mypairs <- c(mypairs, mypair, paste(Dd$y[i], Dd$x[i], sep="."))
    }
  }
  Dd <- Dd[ind, ]
  cond <- apply(Dd[, c("x", "y")], MARGIN=1, FUN=function(x) if(x[1]!=x[2]) return(TRUE) else return(FALSE))
  Dd <- Dd[which(cond==TRUE), ]
  Dd <- Dd[order(abs(Dd$r), decreasing=TRUE), ]
  return(Dd)
}

# Arrange data
dat.A <- read.table(file=counts.file.A, sep="\t", header=TRUE, quote="", stringsAsFactors=FALSE, check.names=FALSE)
rownames(dat.A) <- dat.A[, 1]

dat.B <- read.table(file=counts.file.B, sep="\t", header=TRUE, quote="", stringsAsFactors=FALSE, check.names=FALSE)
rownames(dat.B) <- dat.B[, 1]

meta <- read.table(file=meta.file, sep="\t", header=TRUE, quote="", stringsAsFactors=FALSE, check.names=FALSE)
rownames(meta) <- meta[, 1]
mysamples.A <- intersect(rownames(meta), colnames(dat.A))
mysamples.B <- intersect(rownames(meta), colnames(dat.B))
mysamples <- intersect(mysamples.A, mysamples.B)
dat.A <- as.matrix(dat.A[, mysamples])
dat.B <- as.matrix(dat.B[, mysamples])
meta <- meta[mysamples, ]

myfactors.l <- strsplit(myfactors, split=",")
myfactor1 <- myfactors.l[[1]][1]
if(length(myfactors.l[[1]])==2) myfactor2 <- myfactors.l[[1]][2] else myfactor2 <- ""

if(myfactor2!="") GROUPS <- paste(meta[, myfactor1], meta[, myfactor2], sep=".") else GROUPS <- as.character(meta[, myfactor1])
names(GROUPS) <- mysamples

mylevels <- unlist(strsplit(mylevels, split=","))
mylevels <- mylevels[which(is.element(mylevels, unique(GROUPS)))]
ind <- which(is.element(GROUPS, mylevels))

dat.A <- dat.A[, ind]; dat.B <- dat.B[, ind]
GROUPS <- GROUPS[ind]
meta <- meta[ind, ]

X <- as.data.frame(dat.A)
Y <- as.data.frame(t(dat.B))

# The maximum number of variables for each omic is Nkeep, if a dataset has more than Nkeep variables,
# the most relevant are chosen
if(ncol(X)>Nkeep&ncol(Y)<=Nkeep) RESULT <- spls(X, Y, ncomp = myncomp, keepX=rep(Nkeep, myncomp),
                                                mode = "canonical", scale=TRUE)

if(ncol(X)<=Nkeep&ncol(Y)>Nkeep) RESULT <- spls(X, Y, ncomp = myncomp, keepY=rep(Nkeep, myncomp),
                                                mode = "canonical", scale=TRUE)

if(ncol(X)>Nkeep&ncol(Y)>Nkeep) RESULT <- spls(X, Y, ncomp = myncomp, keepX=rep(Nkeep, myncomp),
                                               keepY=rep(Nkeep, myncomp), mode = "canonical", scale=TRUE)

if(ncol(X)<=Nkeep&ncol(Y)<=Nkeep) RESULT <- spls(X, Y, ncomp = myncomp,
                                                 mode = "canonical", scale=TRUE)

relev.net <- network(RESULT, comp = 1:1, cutoff = mycorcut, #Only variables from the first component are going to be studied
                     color.edge = color.spectral(10),
                     shape.node = c("circle", "rectangle"),
                     show.color.key = TRUE, cex.node.name=0.6)
D.df <- asDataFrame(relev.net$M)
write.table(D.df, file=paste("inner.product.for", study, "tsv", sep="."), sep="\t", quote=FALSE, row.names=FALSE)

D.df <- D.df[which(abs(D.df$r)>=mycorcut), ]

## Dataset with three columns:
## x --> node1
## y --> node2
## r --> pearson correlation score filtered with our selected threshold

write.table(D.df, file=paste("inner.product.filtered.for", study, "tsv", sep="."), sep="\t", quote=FALSE, row.names=FALSE)


